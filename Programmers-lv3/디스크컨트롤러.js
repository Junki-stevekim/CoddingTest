// ë¬¸ì œ ì„¤ëª…
// í•˜ë“œë””ìŠ¤í¬ëŠ” í•œ ë²ˆì— í•˜ë‚˜ì˜ ìž‘ì—…ë§Œ ìˆ˜í–‰í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ë””ìŠ¤í¬ ì»¨íŠ¸ë¡¤ëŸ¬ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ë²•ì€ ì—¬ëŸ¬ ê°€ì§€ê°€ ìžˆìŠµë‹ˆë‹¤. ê°€ìž¥ ì¼ë°˜ì ì¸ ë°©ë²•ì€ ìš”ì²­ì´ ë“¤ì–´ì˜¨ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬í•˜ëŠ” ê²ƒìž…ë‹ˆë‹¤.

// ì˜ˆë¥¼ë“¤ì–´

// - 0ms ì‹œì ì— 3msê°€ ì†Œìš”ë˜ëŠ” Aìž‘ì—… ìš”ì²­
// - 1ms ì‹œì ì— 9msê°€ ì†Œìš”ë˜ëŠ” Bìž‘ì—… ìš”ì²­
// - 2ms ì‹œì ì— 6msê°€ ì†Œìš”ë˜ëŠ” Cìž‘ì—… ìš”ì²­
// ì™€ ê°™ì€ ìš”ì²­ì´ ë“¤ì–´ì™”ìŠµë‹ˆë‹¤. ì´ë¥¼ ê·¸ë¦¼ìœ¼ë¡œ í‘œí˜„í•˜ë©´ ì•„ëž˜ì™€ ê°™ìŠµë‹ˆë‹¤.
// Screen Shot 2018-09-13 at 6.34.58 PM.png

// í•œ ë²ˆì— í•˜ë‚˜ì˜ ìš”ì²­ë§Œì„ ìˆ˜í–‰í•  ìˆ˜ ìžˆê¸° ë•Œë¬¸ì— ê°ê°ì˜ ìž‘ì—…ì„ ìš”ì²­ë°›ì€ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬í•˜ë©´ ë‹¤ìŒê³¼ ê°™ì´ ì²˜ë¦¬ ë©ë‹ˆë‹¤.
// Screen Shot 2018-09-13 at 6.38.52 PM.png

// - A: 3ms ì‹œì ì— ìž‘ì—… ì™„ë£Œ (ìš”ì²­ì—ì„œ ì¢…ë£Œê¹Œì§€ : 3ms)
// - B: 1msë¶€í„° ëŒ€ê¸°í•˜ë‹¤ê°€, 3ms ì‹œì ì— ìž‘ì—…ì„ ì‹œìž‘í•´ì„œ 12ms ì‹œì ì— ìž‘ì—… ì™„ë£Œ(ìš”ì²­ì—ì„œ ì¢…ë£Œê¹Œì§€ : 11ms)
// - C: 2msë¶€í„° ëŒ€ê¸°í•˜ë‹¤ê°€, 12ms ì‹œì ì— ìž‘ì—…ì„ ì‹œìž‘í•´ì„œ 18ms ì‹œì ì— ìž‘ì—… ì™„ë£Œ(ìš”ì²­ì—ì„œ ì¢…ë£Œê¹Œì§€ : 16ms)
// ì´ ë•Œ ê° ìž‘ì—…ì˜ ìš”ì²­ë¶€í„° ì¢…ë£Œê¹Œì§€ ê±¸ë¦° ì‹œê°„ì˜ í‰ê· ì€ 10ms(= (3 + 11 + 16) / 3)ê°€ ë©ë‹ˆë‹¤.

// í•˜ì§€ë§Œ A â†’ C â†’ B ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬í•˜ë©´
// Screen Shot 2018-09-13 at 6.41.42 PM.png

// - A: 3ms ì‹œì ì— ìž‘ì—… ì™„ë£Œ(ìš”ì²­ì—ì„œ ì¢…ë£Œê¹Œì§€ : 3ms)
// - C: 2msë¶€í„° ëŒ€ê¸°í•˜ë‹¤ê°€, 3ms ì‹œì ì— ìž‘ì—…ì„ ì‹œìž‘í•´ì„œ 9ms ì‹œì ì— ìž‘ì—… ì™„ë£Œ(ìš”ì²­ì—ì„œ ì¢…ë£Œê¹Œì§€ : 7ms)
// - B: 1msë¶€í„° ëŒ€ê¸°í•˜ë‹¤ê°€, 9ms ì‹œì ì— ìž‘ì—…ì„ ì‹œìž‘í•´ì„œ 18ms ì‹œì ì— ìž‘ì—… ì™„ë£Œ(ìš”ì²­ì—ì„œ ì¢…ë£Œê¹Œì§€ : 17ms)
// ì´ë ‡ê²Œ A â†’ C â†’ Bì˜ ìˆœì„œë¡œ ì²˜ë¦¬í•˜ë©´ ê° ìž‘ì—…ì˜ ìš”ì²­ë¶€í„° ì¢…ë£Œê¹Œì§€ ê±¸ë¦° ì‹œê°„ì˜ í‰ê· ì€ 9ms(= (3 + 7 + 17) / 3)ê°€ ë©ë‹ˆë‹¤.

// ê° ìž‘ì—…ì— ëŒ€í•´ [ìž‘ì—…ì´ ìš”ì²­ë˜ëŠ” ì‹œì , ìž‘ì—…ì˜ ì†Œìš”ì‹œê°„]ì„ ë‹´ì€ 2ì°¨ì› ë°°ì—´ jobsê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ìž‘ì—…ì˜ ìš”ì²­ë¶€í„° ì¢…ë£Œê¹Œì§€ ê±¸ë¦° ì‹œê°„ì˜ í‰ê· ì„ ê°€ìž¥ ì¤„ì´ëŠ” ë°©ë²•ìœ¼ë¡œ ì²˜ë¦¬í•˜ë©´ í‰ê· ì´ ì–¼ë§ˆê°€ ë˜ëŠ”ì§€ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ìž‘ì„±í•´ì£¼ì„¸ìš”. (ë‹¨, ì†Œìˆ˜ì  ì´í•˜ì˜ ìˆ˜ëŠ” ë²„ë¦½ë‹ˆë‹¤)

// ì œí•œ ì‚¬í•­
// jobsì˜ ê¸¸ì´ëŠ” 1 ì´ìƒ 500 ì´í•˜ìž…ë‹ˆë‹¤.
// jobsì˜ ê° í–‰ì€ í•˜ë‚˜ì˜ ìž‘ì—…ì— ëŒ€í•œ [ìž‘ì—…ì´ ìš”ì²­ë˜ëŠ” ì‹œì , ìž‘ì—…ì˜ ì†Œìš”ì‹œê°„] ìž…ë‹ˆë‹¤.
// ê° ìž‘ì—…ì— ëŒ€í•´ ìž‘ì—…ì´ ìš”ì²­ë˜ëŠ” ì‹œê°„ì€ 0 ì´ìƒ 1,000 ì´í•˜ìž…ë‹ˆë‹¤.
// ê° ìž‘ì—…ì— ëŒ€í•´ ìž‘ì—…ì˜ ì†Œìš”ì‹œê°„ì€ 1 ì´ìƒ 1,000 ì´í•˜ìž…ë‹ˆë‹¤.
// í•˜ë“œë””ìŠ¤í¬ê°€ ìž‘ì—…ì„ ìˆ˜í–‰í•˜ê³  ìžˆì§€ ì•Šì„ ë•Œì—ëŠ” ë¨¼ì € ìš”ì²­ì´ ë“¤ì–´ì˜¨ ìž‘ì—…ë¶€í„° ì²˜ë¦¬í•©ë‹ˆë‹¤.
// ìž…ì¶œë ¥ ì˜ˆ
// jobs	return
// [[0, 3], [1, 9], [2, 6]]	9
// ìž…ì¶œë ¥ ì˜ˆ ì„¤ëª…
// ë¬¸ì œì— ì£¼ì–´ì§„ ì˜ˆì™€ ê°™ìŠµë‹ˆë‹¤.

// 0ms ì‹œì ì— 3ms ê±¸ë¦¬ëŠ” ìž‘ì—… ìš”ì²­ì´ ë“¤ì–´ì˜µë‹ˆë‹¤.
// 1ms ì‹œì ì— 9ms ê±¸ë¦¬ëŠ” ìž‘ì—… ìš”ì²­ì´ ë“¤ì–´ì˜µë‹ˆë‹¤.
// 2ms ì‹œì ì— 6ms ê±¸ë¦¬ëŠ” ìž‘ì—… ìš”ì²­ì´ ë“¤ì–´ì˜µë‹ˆë‹¤.
// ë¬¸ì œê°€ ìž˜ ì•ˆí’€ë¦°ë‹¤ë©´ðŸ˜¢
// ížŒíŠ¸ê°€ í•„ìš”í•œê°€ìš”? [ì½”ë”©í…ŒìŠ¤íŠ¸ ì—°ìŠµ ížŒíŠ¸ ëª¨ìŒì§‘]ìœ¼ë¡œ ì˜¤ì„¸ìš”! â†’ í´ë¦­


function solution(jobs) {
    const count = jobs.length;
    const minHeap = new MinHeap();
    jobs.sort((a,b) => a[0]-b[0]);
    
    let time = 0;
    let complete = 0;
    let total = 0;
    
    while(jobs.length || minHeap.size()) {
      while(jobs.length) {
        if(jobs[0][0] === time) {
          minHeap.heappush(jobs.shift());
        } else break;
      }
      
      if(minHeap.size() && time >= complete) {
        const task = minHeap.heappop();
        complete = task[1] + time;
        total += complete - task[0];
      }
      time++;
    }
    
    return total / count >> 0;
  }
  
  class MinHeap {
      constructor() {
          this.heap = [ null ];
      }
      
      size() {
          return this.heap.length - 1;
      }
      
      getMin() {
          return this.heap[1] ? this.heap[1] : null;
      }
      
      swap(a, b) {
          [ this.heap[a], this.heap[b] ] = [ this.heap[b], this.heap[a] ];
      }
      
      heappush(value) {
          this.heap.push(value);
          let curIdx = this.heap.length - 1;
          let parIdx = (curIdx / 2) >> 0;
          
          while(curIdx > 1 && this.heap[parIdx][1] > this.heap[curIdx][1]) {
              this.swap(parIdx, curIdx)
              curIdx = parIdx;
              parIdx = (curIdx / 2) >> 0;
          }
      }
      
      heappop() {
          const min = this.heap[1];	
          if(this.heap.length <= 2) this.heap = [ null ];
          else this.heap[1] = this.heap.pop();   
          
          let curIdx = 1;
          let leftIdx = curIdx * 2;
          let rightIdx = curIdx * 2 + 1; 
          
          if(!this.heap[leftIdx]) return min;
          if(!this.heap[rightIdx]) {
              if(this.heap[leftIdx][1] < this.heap[curIdx][1]) {
                  this.swap(leftIdx, curIdx);
              }
              return min;
          }
  
          while(this.heap[leftIdx][1] < this.heap[curIdx][1] || this.heap[rightIdx][1] < this.heap[curIdx][1]) {
              const minIdx = this.heap[leftIdx][1] > this.heap[rightIdx][1] ? rightIdx : leftIdx;
              this.swap(minIdx, curIdx);
              curIdx = minIdx;
              leftIdx = curIdx * 2;
              rightIdx = curIdx * 2 + 1;
              
              if(leftIdx >= this.size()) break;
          }
  
          return min;
      }
  }